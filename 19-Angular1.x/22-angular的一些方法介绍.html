<html>
<head>
  <title>22-angular的一些方法介绍</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="593"/>
<h1>22-angular的一些方法介绍</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2017/3/7 星期二 17:45</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2017/4/25 星期二 9:47</i></td></tr>
<tr><td><b>作者：</b></td><td><i>王平安</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><p><strong><span style="color: #0000ff">一.Main方法在哪里</span></strong></p><p>        如果你是从Java或者Python编程语言转过来的，那么你可能很想知道AngularJS里面的main方法在哪里？这个把所有东西启动起来，并且第一个被执行的方法在哪里？JavaScript代码里面负责实例化并且把所有东西组合到一起，然后命令应用开始运行的那个方法在哪里？</p><p>        事实上，AngularJS并没有main方法，AngularJS使用模块的概念来代替main方法。模块允许我们通过声明的方式来描述应用中的依赖关系，以及如何进行组装和启动。使用这种方式的原因如下：</p><p>        1.模块是声明式的。这就意味着它编写起来更加容易，同时理解起来也很容易，阅读它就像读普通的英文一样！</p><p>        2.它是模块化的。这就迫使你去思考如何定义你的组件和依赖关系，让它们变得更加清晰。</p><p>        3.它让测试更加容易。在单元测试吕，你可以有选择地加入模块，并且可以避免代码中存在无法进行单元测试的内容。同时，在场景测试中，你可以加载其他额外的模块，这样就可以更好地和其他组件配合使用。</p><p>        例如，在我们的应用中有一个叫做&quot;MyAwesomeApp&quot;的模块。在HTML里面，只要把以下内容添加到&lt;html&gt;标签中（或者从技术上说，可以添加到任何标签中）：</p><div><a style="CURSOR: pointer"><u>复制代码</u></a> 代码如下:</div><div><br/>
&lt;html ng-app=&quot;MyAwesomeApp&quot;&gt;<br/></div><p> ng-app指令就会告诉AngularJS使用MyAwesomeApp模块来启动你的应用。那么，应该如何定义模块呢？举例来说，我们建议你为服务、指令和过滤器分别定义不同的模块。然后你的主模块可以声明依赖这些模块。</p><p>        这样可以使得模块管理更加容易，因为它们都是良好的、完备的代码块，每个模块有且只有一种职能。同时，单元测试可以只加载它们所关注的模块，这样就可以减少初始化的次数，单元测试也会变得更精致、更专注。</p><p><span style="color: #0000ff"><strong>二.加载和依赖</strong></span></p><p>        模块加载动作发生在两个不同的阶段，这一点从函数名上面就可以反映出来，它们分别是Config代码块和Run代码块（或者叫做阶段）。</p><p><strong>1.Config代码块</strong></p><p>        在这一阶段里面，AngularJS会连接并注册好所有数据源。因此，只有数据源和常量可以注入到Config代码块中。那些不确定是否已经初始化好的服务不能注入进来。</p><p><strong>2.Run代码块</strong></p><p>        Run代码块用来启动你的应用，并且在注射器创建完成之后开始执行。为了避免在这一点开始之后再对系统进行配置操作，只有实例和常量可以被注入到Run代码块中。你会发现，在AngularJS中，Run代码块是与main方法最类似的东西。</p><p><strong><span style="color: #0000ff">三.快捷方法</span></strong></p><p>        利用模块可以做什么呢？我们可以用它来实例化控制器、指令、过滤器以及服务，但是利用模块类还可以做更多事情。如下模块配置的API方法：</p><p><strong>1.config(configFn)</strong></p><p>        利用此方法可以做一些注册工作，这些工作需要在模块加载时完成。</p><p><strong>2.constant(name, object)</strong></p><p>        此方法会首先运行，所以你可以用它来声明整个应用范围内的常量，并且让它们在所有配置（config方法）和实例（后面的所有方法，例如controller、service等）方法中可用。</p><p><strong>3.controller(name,constructor)</strong></p><p>        它的基本作用是配置好控制器方便后面使用。</p><p><strong>4.directive(name,directiveFactory)</strong></p><p>        可以使用此方法在应用中创建指令。</p><p><strong>5.filter(name,filterFactory)</strong></p><p>        允许你创建命名的AngularJS过滤器，就像前面章节所讨论的那样。</p><p><strong>6.run(initializationFn)</strong></p><p>        如果你想要在注射器启动之后执行某些操作，而这些操作需要在页面对用户可用之前执行，就可以使用此方法。</p><p><strong>7.value(name,object)</strong></p><p>        允许在整个应用中注射值。</p><p><strong>8.factory(name,factoryFn)</strong></p><p>        如果你有一个类或者对象，需要首先为它提供一些逻辑或者参数，然后才能对它初始化，那么你就可以使用这里的factory接口。factory是一个函数，它负责创建一些特定的值（或者对象）。我们来看一个greeter(打招呼)函数的实例，这个函数需要一条问候语来初始化：</p></div><div><a href="http://www.jb51.net/article/76015.htm#">?</a></div><table border="0" cellpadding="0" cellspacing="0" style="table-layout:fixed;width:26.838514025777105%;"><tr><td style="width:12.429378531073446%;"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></td><td style="width:87.57062146892656%;"><div><code>function<span style="font-family: 微软雅黑;"> </span></code><code>Greeter(salutation) {</code></div><div style="margin-left:40px;"><code> </code><code>this</code><code>.greet =</code> <code>function</code><code>(name) {</code></div><div style="margin-left:40px;"><code> </code><code>return</code> <code>salutation +</code> <code>' '</code> <code>+ name;</code></div><div style="margin-left:40px;"><code>};</code></div><div><code>}</code></div></td></tr></table><div><br/></div><div><p> greeter函数示例如下：</p><div><div><a href="http://www.jb51.net/article/76015.htm#">?</a></div><table border="0" cellpadding="0" cellspacing="0" style="width:340px;"><tr><td style="width:10.294117647058822%;"><div>1</div><div>2</div><div>3</div></td><td style="width:90.00331564986737%;"><div><code>myApp.factory(</code><code>'greeter'</code><code>,</code> <code>function</code><code>(salut) {</code></div><div><code> </code><code>return</code> <code>new</code> <code>Greeter(salut);</code></div><div><code>});</code></div></td></tr></table></div><p> 然后可以这样来调用它：</p><div><div><a href="http://www.jb51.net/article/76015.htm#">?</a></div><table border="0" cellpadding="0" cellspacing="0" style="width:260px;"><tr><td style="width:13.461538461538462%;"><div>1</div></td><td style="width:86.95652173913044%;"><div><code>var</code> <code>myGreeter = greeter(</code><code>'Halo'</code><code>);</code></div></td></tr></table></div><p><strong>9.service(name,object)</strong></p><p>        factory和service之间的不同点在于，factory会直接调用传递给它的函数，然后返回执行的结果；而service将会使用&quot;new&quot;关键字来调用传递给它的构造方法，然后再返回结果。所以，前面的greeter Factory可以替换成下面这个greeter Service：</p><div><div><a href="http://www.jb51.net/article/76015.htm#">?</a></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>1</div></td><td><div><code>myApp.service(</code><code>'greeter'</code><code>, Greeter);</code></div></td></tr></tbody></table></div><p> 每当我们需要一个greeter实例的时候，AngularJS就会调用新的Greeter()来返回一个实例。</p><p><strong>10.provider(name,providerFn)</strong></p><p>        provider是这几个方法中最复杂的部分（显然，也是可配置性最好的部分）。provider中既绑定了factory也绑定了service，并且在注入系统准备完毕之前，还可以享受到配置provider函数的好处（也就是config块）。</p><p>        我们来看看使用provider改造之后的greeter Service是什么样子：</p><div><div><a href="http://www.jb51.net/article/76015.htm#">?</a></div><table border="0" cellpadding="0" cellspacing="0" style="width:316px;"><tbody><tr><td style="width:11.075949367088606%;"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div></td><td style="width:88.99595687331536%;"><div><code>myApp.provider(</code><code>'greeter'</code><code>,</code> <code>function</code><code>() {</code></div><div><code> </code><code>var</code> <code>salutation =</code> <code>'Hello'</code><code>;</code></div><div><code> </code><code>this</code><code>.setSalutation =</code> <code>function</code><code>(s) {</code></div><div><code> </code><code>salutation = s;</code></div><div><code>}</code></div><div><code> </code><code>function</code> <code>Greeter(a) {</code></div><div><code> </code><code>this</code><code>.greet =</code> <code>function</code><code>() {</code></div><div><code> </code><code>return</code> <code>salutation +</code> <code>' '</code> <code>+ a;</code></div><div><code>}</code></div><div><code>}</code></div><div><code> </code><code>this</code><code>.$get =</code> <code>function</code><code>(a) {</code></div><div><code> </code><code>return</code> <code>new</code> <code>Greeter(a);</code></div><div><code>};</code></div><div><code>});</code></div></td></tr></tbody></table></div><p>这样我们就可以在运行时动态设置问候语了（例如，可以根据用户使用的不同语言进行设置）。</p></div><div><a href="http://www.jb51.net/article/76015.htm#">?</a></div><div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>1</div><div>2</div><div>3</div></td><td><div><code>var</code> <code>myApp = angular.module(myApp, []).config(</code><code>function</code><code>(greeterProvider) {</code></div><div><code>greeterProvider.setSalutation(</code><code>'Namaste'</code><code>);</code></div><div><code>});</code></div></td></tr></tbody></table></div></span>
</div></body></html> 