<html>
<head>
  <title>65-JavaScript中8个常见的陷阱</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1814"/>
<h1>65-JavaScript中8个常见的陷阱</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2017/6/28 星期三 15:29</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2017/6/28 星期三 15:31</i></td></tr>
<tr><td><b>作者：</b></td><td><i>王平安</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><h3>1. 你是否尝试过对数组元素进行排序？</h3><p>JavaScript默认使用字典序(alphanumeric)来排序。因此，<code>[1,2,5,10].sort()</code>的结果是<code>[1, 10, 2, 5]</code>。</p></div><div><br/></div><div>如果你想正确的排序，应该这样做：<code>[1,2,5,10].sort((a, b) =&gt; a - b)</code></div><div><code>[10,5,2,1].sort((a, b) =&gt; b - a)</code></div><div><h3><a href="https://blog.fundebug.com/2017/06/28/who-said-js-was-easy/#2-new-Date-%E5%8D%81%E5%88%86%E5%A5%BD%E7%94%A8" title="2. new Date() 十分好用"></a>2. new Date() 十分好用</h3><p><code>new Date()</code>的使用方法有：</p><ul><li>不接收任何参数：返回当前时间；</li><li>接收一个参数<code>x</code>: 返回1970年1月1日 + <code>x</code>毫秒的值。</li><li><code>new Date(1, 1, 1)</code>返回1901年2月1号。</li><li>然而….，<code>new Date(2016, 1, 1)</code>不会在1900年的基础上加2016，而只是表示2016年。</li></ul><h3><a href="https://blog.fundebug.com/2017/06/28/who-said-js-was-easy/#3-%E6%9B%BF%E6%8D%A2%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E7%9C%9F%E7%9A%84%E6%9B%BF%E6%8D%A2%EF%BC%9F" title="3. 替换函数没有真的替换？"></a>3. 替换函数没有真的替换？</h3><table style="width:259px;"><tbody><tr><td style="width:98.45559845559846%;"><div>let s = &quot;bob&quot;</div><div>const replaced = s.replace('b', 'l')</div><div>replaced === &quot;lob&quot; // 只会替换掉第一个b</div><div>s === &quot;bob&quot; // 并且s的值不会变</div></td></tr></tbody></table><p>如果你想把所有的b都替换掉，要使用正则：<br/></p><table style="width:199px;"><tbody><tr><td style="width:97.98994974874373%;"><div>&quot;bob&quot;.replace(/b/g, 'l') === 'lol'</div></td></tr></tbody></table><h3><a href="https://blog.fundebug.com/2017/06/28/who-said-js-was-easy/#4-%E8%B0%A8%E6%85%8E%E5%AF%B9%E5%BE%85%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97" title="4. 谨慎对待比较运算"></a>4. 谨慎对待比较运算</h3><table style="width:168px;"><tbody><tr><td style="width:97.61904761904762%;"><div>// 这些可以</div><div>'abc' === 'abc' // true</div><div>1 === 1 // true</div><div>// 然而这些不行</div><div>[1,2,3] === [1,2,3] // false</div><div>{a: 1} === {a: 1} // false</div><div>{} === {} // false</div></td></tr></tbody></table><p>因为[1,2,3]和[1,2,3]是两个不同的数组，只是它们的元素碰巧相同。因此，不能简单的通过<code>===</code>来判断。</p><h3><a href="https://blog.fundebug.com/2017/06/28/who-said-js-was-easy/#5-%E6%95%B0%E7%BB%84%E4%B8%8D%E6%98%AF%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B" title="5. 数组不是基础类型"></a>5. 数组不是基础类型</h3><table style="width:189px;"><tbody><tr><td style="width:97.88359788359789%;"><div>typeof {} === 'object' // true</div><div>typeof 'a' === 'string' // true</div><div>typeof 1 === number // true</div><div>// 但是....</div><div>typeof [] === 'object' // true</div></td></tr></tbody></table><p>如果要判断一个变量<code>var</code>是否是数组，你需要使用<code>Array.isArray(var)</code>。</p><h3><a href="https://blog.fundebug.com/2017/06/28/who-said-js-was-easy/#6-%E9%97%AD%E5%8C%85" title="6. 闭包"></a>6. 闭包</h3><p>这是一个经典的JavaScript面试题：<br/></p><table style="width:305px;"><tbody><tr><td style="width:98.68852459016394%;"><div>const Greeters = []</div><div>for (var i = 0 ; i &lt; 10 ; i++) {</div><div>Greeters.push(function () { return console.log(i) })</div><div>}</div><div>Greeters[0]() // 10</div><div>Greeters[1]() // 10</div><div>Greeters[2]() // 10</div></td></tr></tbody></table><p>虽然期望输出0,1,2,…，然而实际上却不会。知道如何Debug嘛？<br/>
有两种方法：</p><ul><li>使用<code>let</code>而不是<code>var</code>。备注：可以参考Fundebug的另一篇博客 <a href="https://blog.fundebug.com/2017/05/04/%20%20hy-you-should-not-use-var/" rel="external" target="_blank">ES6之”let”能替代”var”吗?</a></li><li><p>使用<code>bind</code>函数。备注：可以参考Fundebug的另一篇博客 <a href="https://blog.fundebug.com/2017/05/17/%20%20avascript-this-for-beginners/" rel="external" target="_blank">JavaScript初学者必看“this”</a></p><table style="width:238px;"><tbody><tr><td style="width:98.31932773109243%;"><div>Greeters.push(console.log.bind(null, i))</div></td></tr></tbody></table><p>当然，还有很多解法。这两种是我最喜欢的！</p></li></ul><h3><a href="https://blog.fundebug.com/2017/06/28/who-said-js-was-easy/#7-%E5%85%B3%E4%BA%8Ebind" title="7. 关于bind"></a>7. 关于<code>bind</code></h3><p>下面这段代码会输出什么结果？<br/></p><table style="width:230px;"><tbody><tr><td style="width:98.26086956521739%;"><div>class Foo {</div><div>constructor (name) {</div><div>this.name = name</div><div>}</div><div>greet () {</div><div>console.log('hello, this is ', this.name)</div><div>}</div><div>someThingAsync () {</div><div>return Promise.resolve()</div><div>}</div><div>asyncGreet () {</div><div>this.someThingAsync()</div><div>.then(this.greet)</div><div>}</div><div>}</div><div>new Foo('dog').asyncGreet()</div></td></tr></tbody></table><p>如果你说程序会崩溃，并且报错：Cannot read property ‘name’ of undefined。<br/>
因为第16行的<code>geet</code>没有在正确的环境下执行。当然，也有很多方法解决这个BUG！</p><ul><li><p>我喜欢使用<code>bind</code>函数来解决问题：</p><table style="width:162px;"><tbody><tr><td style="width:97.53086419753086%;"><div>asyncGreet () {</div><div>this.someThingAsync()</div><div>.then(this.greet.bind(this))</div><div>}</div></td></tr></tbody></table><p>这样会确保<code>greet</code>会被Foo的实例调用，而不是局部的函数的<code>this</code>。</p></li><li><p>如果你想要<code>greet</code>永远不会绑定到错误的作用域，你可以在构造函数里面使用<code>bind</code>来绑 。</p><table style="width:198px;"><tbody><tr><td style="width:97.97979797979798%;"><div>class Foo {</div><div>constructor (name) {</div><div>this.name = name</div><div>this.greet = this.greet.bind(this)</div><div>}</div><div>}</div></td></tr></tbody></table></li><li><p>你也可以使用箭头函数(=&gt;)来防止作用域被修改。备注：可以参考Fundebug的另一篇博客 <a href="https://blog.fundebug.com/2017/05/25/%20%20rrow-function-for-beginner/" rel="external" target="_blank">JavaScript初学者必看“箭头函数”</a>。</p><table style="width:143px;"><tbody><tr><td style="width:97.2027972027972%;"><div>asyncGreet () {</div><div>this.someThingAsync()</div><div>.then(() =&gt; {</div><div>this.greet()</div><div>})</div><div>}</div></td></tr></tbody></table></li></ul><h3><a href="https://blog.fundebug.com/2017/06/28/who-said-js-was-easy/#8-Math-min-%E6%AF%94Math-max-%E5%A4%A7" title="8. Math.min()比Math.max()大"></a>8. <a href="https://zhuanlan.zhihu.com/p/22481953" rel="external" target="_blank">Math.min()比Math.max()大</a></h3><table style="width:209px;"><tbody><tr><td style="width:98.08612440191388%;"><div>Math.min() &lt; Math.max() // false</div></td></tr></tbody></table></div><div><br/></div><div>因为Math.min() 返回 Infinity, 而 Math.max()返回 -Infinity。</div></span>
</div></body></html> 